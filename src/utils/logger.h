#pragma once

#include <string>
#include <thread>
#include <queue>
#include <mutex>
#include <chrono>
#include <assert.h>
#include <map>

#include "utils/semaphore.h"
#include "utils/log_file_writer.h"

namespace tx_utils {

// log levels
enum tx_log_level {
    ERROR = 1,
    WARN = 2,
    INFO = 3,
    DEBUG = 4
};

// a lightweight logger for VideoPipe, architecture: N producer * 1 consumer.
// 1. support 3 types of devices (console, file, kafka)
// 2. multithread safe
// 3. use Macros directly
class tx_logger {
private:
    std::queue<std::string> log_cache;
    tx_utils::tx_semaphore log_cache_semaphore;
    std::mutex log_cache_mutex;
    std::thread log_writer_th;

    // initialized or not
    bool inited = false;

    bool alive = true;
    void die();

    tx_logger(/* args */);

    // write to devices
    void write_to_console(const std::string &log);
    void write_to_file(const std::string &log);
    void write_to_kafka(const std::string &log);

    // writing log func
    void log_write_run();

    // file writer
    tx_utils::tx_log_file_writer file_writer;

    const std::map<tx_log_level, std::string> log_level_names = {{ERROR, "Error"},
                                                                 {WARN, "Warn "},
                                                                 {INFO, "Info "},
                                                                 {DEBUG, "Debug"}};

public:
    // non-copable
    tx_logger(const tx_logger &) = delete;
    tx_logger &operator=(const tx_logger &) = delete;

    // singleton
    static tx_logger &get_logger() {
        static tx_logger logger;
        return logger;
    }
    ~tx_logger();

    // CONFIG
    tx_log_level log_level = tx_log_level::DEBUG;                  // filter
    std::string log_dir = "./log";                                 // folder saving log file
    std::string kafka_servers_and_topic = "127.0.0.1:9092/tx_log"; // kafka servers and topic, splited by `/`. multiple servers splited by `,`
    const std::string log_file_name_template = "<year>-<mon>-<day>.txt";
    const std::string log_time_templete = "[<year>-<mon>-<day> <hour>:<min>:<sec>.<mili>]";

    /*
        * keywords as filters for the log of debug level since it always writes too frequently, empty means no filters.
        * use the name of a node is a normal method to apply this function,
        * `file_src_0` means write all debug log generated by the node named file_src_0.
        */
    std::vector<std::string> keywords_for_debug_log = {};

    // watch
    int log_cache_warn_threshold = 100; // warning if cache size greater than threshold

    // where
    bool log_to_console = true; // to console
    bool log_to_file = true;    // to file
    bool log_to_kafka = false;  // to kafka

    // how
    const bool include_time = true;    // `log time` part in log content (readonly)
    bool include_level = true;         // `log level` part in log content
    bool include_code_location = true; // `log from` part in log content
    bool include_thread_id = true;     // 'thread id' part in log content
    // END of CONFIG

    // better Never call directly
    void log(tx_log_level level, const std::string &message, const char *code_file, int code_line);

    // init for tx_logger, ready to go
    void init();
}; // class tx_logger

// config Macros
#define SET_LOG_INCLUDE_CODE_LOCATION(_include_code_location) tx_utils::tx_logger::get_logger().include_code_location = _include_code_location
#define SET_LOG_INCLUDE_THREAD_ID(_include_thread_id) tx_utils::tx_logger::get_logger().include_thread_id = _include_thread_id

// log Macros
// use tx_utils::string_format to format log content first if need
// example:
// TX_ERROR(tx_utils::string_format("message is %s at %d", s, d));
#define TX_ERROR(message) tx_utils::tx_logger::get_logger().log(tx_utils::tx_log_level::ERROR, message, __FILE__, __LINE__)
#define TX_WARN(message) tx_utils::tx_logger::get_logger().log(tx_utils::tx_log_level::WARN, message, __FILE__, __LINE__)
#define TX_INFO(message) tx_utils::tx_logger::get_logger().log(tx_utils::tx_log_level::INFO, message, __FILE__, __LINE__)
#define TX_DEBUG(message) tx_utils::tx_logger::get_logger().log(tx_utils::tx_log_level::DEBUG, message, __FILE__, __LINE__)

// init Macros
#define LOGGER_INIT() tx_utils::tx_logger::get_logger().init()

} // namespace tx_utils
