#pragma once

#include <string>
#include <thread>
#include <queue>
#include <mutex>
#include <chrono>
#include <assert.h>
#include <map>

#include "utils/semaphore.h"
#include "utils/log_file_writer.h"

namespace tx_utils {

// log levels
enum LogLevel {
    ERROR = 1,
    WARN = 2,
    INFO = 3,
    DEBUG = 4
};

// a lightweight logger for VideoPipe, architecture: N producer * 1 consumer.
// 1. support 3 types of devices (console, file, kafka)
// 2. multithread safe
// 3. use Macros directly
class Logger {
private:
    std::queue<std::string> log_cache_;
    tx_utils::Semaphore log_cache_semaphore_;
    std::mutex log_cache_mutex_;
    std::thread log_writer_th_;

    // initialized or not
    bool inited_ = false;

    bool alive_ = true;
    void die();

    Logger(/* args */);

    // write to devices
    void write_to_console(const std::string &log);
    void write_to_file(const std::string &log);
    void write_to_kafka(const std::string &log);

    // writing log func
    void log_write_run();

    // file writer
    tx_utils::LogFileWriter file_writer_;

    const std::map<LogLevel, std::string> log_level_names_ = {{ERROR, "Error"},
                                                              {WARN, "Warn "},
                                                              {INFO, "Info "},
                                                              {DEBUG, "Debug"}};

public:
    // non-copable
    Logger(const Logger &) = delete;
    Logger &operator=(const Logger &) = delete;

    // singleton
    static Logger &get_logger() {
        static Logger logger;
        return logger;
    }
    ~Logger();

    // CONFIG
    LogLevel log_level_ = LogLevel::DEBUG;                          // filter
    std::string log_dir_ = "./log";                                 // folder saving log file
    std::string kafka_servers_and_topic_ = "127.0.0.1:9092/tx_log"; // kafka servers and topic, splited by `/`. multiple servers splited by `,`
    const std::string log_file_name_template_ = "<year>-<mon>-<day>.txt";
    const std::string log_time_templete_ = "[<year>-<mon>-<day> <hour>:<min>:<sec>.<mili>]";

    /*
        * keywords as filters for the log of debug level since it always writes too frequently, empty means no filters.
        * use the name of a node is a normal method to apply this function,
        * `file_src_0` means write all debug log generated by the node named file_src_0.
        */
    std::vector<std::string> keywords_for_debug_log_ = {};

    // watch
    int log_cache_warn_threshold_ = 100; // warning if cache size greater than threshold

    // where
    bool log_to_console_ = true; // to console
    bool log_to_file_ = true;    // to file

    // how
    const bool include_time_ = true;    // `log time` part in log content (readonly)
    bool include_level_ = true;         // `log level` part in log content
    bool include_code_location_ = true; // `log from` part in log content
    bool include_thread_id_ = true;     // 'thread id' part in log content
    // END of CONFIG

    // better Never call directly
    void log(LogLevel level, const std::string &message, const char *code_file, int code_line);

    // init for tx_logger, ready to go
    void init();
}; // class tx_logger

// config Macros
#define SET_LOG_LEVEL(_log_level) tx_utils::Logger::get_logger().log_level_ = _log_level
#define SET_LOG_INCLUDE_CODE_LOCATION(_include_code_location) tx_utils::Logger::get_logger().include_code_location_ = _include_code_location
#define SET_LOG_INCLUDE_THREAD_ID(_include_thread_id) tx_utils::Logger::get_logger().include_thread_id_ = _include_thread_id

// log Macros
// use tx_utils::string_format to format log content first if need
// example:
// TX_ERROR(tx_utils::string_format("message is %s at %d", s, d));
#define TX_ERROR(message) tx_utils::Logger::get_logger().log(tx_utils::LogLevel::ERROR, message, __FILE__, __LINE__)
#define TX_WARN(message) tx_utils::Logger::get_logger().log(tx_utils::LogLevel::WARN, message, __FILE__, __LINE__)
#define TX_INFO(message) tx_utils::Logger::get_logger().log(tx_utils::LogLevel::INFO, message, __FILE__, __LINE__)
#define TX_DEBUG(message) tx_utils::Logger::get_logger().log(tx_utils::LogLevel::DEBUG, message, __FILE__, __LINE__)

// init Macros
#define LOGGER_INIT() tx_utils::Logger::get_logger().init()

} // namespace tx_utils
